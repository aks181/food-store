> Before building always plan your app, visualize it using wire-frames, mockups, designs etc

> Comments in JSX can be written using {/*   */}
> Lay out a basic component structure/hierarchy
> Passing a props to a component is same as passing an argument to a function  
> props is an object
> pass any number of props and use as props in the comp 
> Config driven UI - website driven UI/data/configuration (diff UI based on diff parameters) 
> props can be used as props object or destructure on the fly or destructure in component

> use map instead of for loop to render lists
> use a unique key for each list item mandatorily as it helps react to uniquely identify each element so that when lists are modified, older elements are not rerendered, only new ones are rendered
> if no unique key is available then index can be used as key but it is not recommended
> use index only and only if list is static, contents are fixed with no possible addition/deletion/modification and a unique id is not present in data

✅when using images in react mostly local images stored at some path, they dont render by just specifying the path(both with parcel and webpack), to load them either - 
    1-> do path={require('../../imgPAth.jpg")}
    2-> const url = new URL('../imgpath', import.meta.url); 
    img src={url}
    3-> import logo from '../../filepath.jps'
    img src={logo}

/******** Assg -4 ***************/
> <React.Fragment></React.Fragment> can be used to enclose multiple elements if we want to return them from one component without adding extra dom nodes like divs. e.g. a Columns component will return multiple <td>s so they can be enclosed within or <></>. Only key attribute can be used and that too with React.Fragment

Ep.5--
> follow any type of folder structure which suits your needs and organizes well
> Components files can be inside components folder but should start with a capital letter and SHOULD/CAN match the component name
> extension can be .js or .jsx, similarly while importing u can write/avoid .js/.jsx
> Imports/Exports 2 types-
    1. Default import/Exports
    (can be only 1 in a file)

    export default ComponentName
    import ComponentName from "path";

    22. Named import/export
    (used when multiple exports are needed from same file)

    export const VARIABLE_1 = __ ;
    export const VARIABLE_2 = ** ;
    import { VARIABLE_1 } from "path";

> We can do both Named and default exports from same file.

> We can use onClick, onMouseEnter etc events on elements like onClick={() => {callback function JS code}}

/*********************************** HOOKS **************/

> React is good at rendering, rerendering and dom manipulations

> Hook is a normal JS utility function 
> If we modify a list stored in a normal JS variable(e.g.filter), the variable's value changes but it is not reflected on the UI.
> State is a super powerful variable which is created as
    const [listOfHotels, setListOfHotels] = useState([])
    useState takes default value of the state variable
> If we update the list using a state variable then it automatically refreshes/updates the UI(render) provided that we update the value using the set function ONLY(This triggers diff algorithm).
UI is kept in sync with the data(ui layer and data layer). => When a state variable updates, then react rerenders the component.
> useState basically returns an array whose arr[0]= listOfHotels and arr[1]=setListOfHotels (we just use array destructuring on the fly)

=> Best practices related to hooks :- 
> no use of useState outside component - also throws error- since it is used to create local state variables inside function component
> declare all useState hooks at the top
> don't use useState inside conditions, for loops, inside functions like if(valid but not to be done)
> Don't create component inside component
> useEffect can be used multiple times in a component

=> Reconciliation Algorithm (React Fiber came in R16) - 
- Virtual DOM - is representation of actual DOM ( JS object created by a component )
- Diff Algorithm calculates diff between old and new virtual DOM and then updates the DOM
- React efficiently keeps track of all DOM nodes and using their corresponding objects(virtual dom for React) compares the changes and updates the UI
- Reconciliation is the process by which VDOM is kept in sync with the real DOM by a library like ReactDOM
- Apart from React elements, react also uses internal objects(fibers) to hold additional info about the component tree.

========================= EP 6- Explore the world ====================
> Monolith vs Microservices architecture
In Monolith, all the services exist within one single massive project, all backend, database, UI, auth etc and for even small change the whole project is built and deployed.
In microservices, all services are standalone in themselves having their own tech stack and functionality, and interact with each other to form a complete application. This is known as separation of concerns or single responsibility principle. These services operate on different ports and all these ports are connected to the backend 

=> Approaches to fetch data from any API
    1. Load the app -> fetch the data(wait till it comes) -> render the UI
    2. Load the app -> Render the UI -> fetch the data -> rerender the UI
In React, we will follow 2 as it provides better UX

=> useEffect Hook -
    useEffect(); --function
    useEffect(a,b); --takes 2 arguments
    useEffect(() => {
        //callback function
    }, [])          --first is a callback function, 2nd is a dependency array

    This useEffect hook callback function code is run AFTER the component has rendered.

⭐=> dependency array is not mandatory only callback function is mandatory. 3 cases-
    1. useEffect(() => { //... }) ==> no dep array, so function will be executed after every    render
    2. useEffect(() => { //... }, []) ==> empty dep array, so function will be executed ONLY after first/initial render
    3. useEffect(() => { // ... }, [dependencyVariable]) ==> called after initial and after every time dependencyVariable changes

- Conditional rendering - rendering based on some condition. e.g. Shimmer UI
- when any local state variable is updated, react triggers a reconciliation cycle and the WHOLE component is rerendered (component function is called again), and not just the changing thing e.g. if login btn changes to logout in complete header, not just btn but whole component rerenders
- when setStateVariable is called, it rerenders the whole component with a new stateVariable which is a new stateVariable different from previous i.e. why we destructure useState using const 
- to show fetched data on UI, u will need state variables

========================= EP 7 - Routing ====================
> library is react-router-dom (latest v is 6.11+) - also 5 was majorly used before
> first we import createBrowserRouter in our app component
> this createBrowserRouter takes in a config which is an array of objects, in which each object corresponds to a route and the component that needs to be displayed on the route (Component name is written as is not </> notation)
> we can also use element to specify component but then write in <>
> it also provides a RouterProvider component that provides our routes to the app and renders them
> to handle unknown routes, a config object can also have errorElement which specifies the component to render on error (Component name has to be in component notation)
> useRouterError() is a hook provided by react-router-dom which tells details about the error and can be used for better error handling ux

> Child routes - sub routes for a path
> Outlet - just like <router-outlet> - gets replaced by component as per route
> Link - makes anything a link, instead of a href we use Link to="route"
> client-side routing - what we do on react vs server side routing what we do in normal web pages

> Link element at the end is an <a href> on UI
> key attrib should always be on the parent element that is rendered using map
